[TOC]



我得保证这里面每行代码都是我写的才行😁

本书68个题目

## 第1章 面试的流程

这章没有题目，主要是讲了面试的流程，本章节就一点比较重要：

- 面试要演面试官

但我还想补充，同时你也要面一下面试官，比如：

- 问清楚去了具体做啥，不要面C去了才知道写Go  TAT
- 通过请教面试官深刻的技术问题表达培养潜力（不是）
- 

## 第2章 面试需要的基础知识



#### 面试题 01 赋值运算符函数

有一个含有char数组的字符串对象，写出它的赋值运算符函数。



- 考虑基本情况
  - 入参需为常量
  - 连续赋值语句需要返回引用
  - 被赋值的对象要先释放内存
  - 判断自己给自己赋值
- 考虑异常安全性



#### 面试题 03 数组中重复的数字

##### 题目1

> 长度 `n` ，取值 `[0, n-1]共n个数` 的随机数数组，可能会有一个值多次出现，请找出其中任意一个重复数字。

##### 思路

这道题最简单的解法有两个：排序找重、哈希表找重

1. 不用额外空间O(nlogn) 排序

对数组进行排序，重复的数会连在一起，在扫描看那些连起来了就行。

不需要额外空间，空间复杂度O(1)

排序再扫一遍排序后的数组，时间复杂度O(nlogn)

很简单，不提供代码

2. 解2：使用额外空间O(n) 哈希表

太慢了，如何加速呢？可以用哈希表

用哈希表保存每个数值是否出现或出现几次

哈希表需要另开数组，空间复杂度O(n)

过一遍整个数组，时间复杂度O(n)

很简单，不提供代码



3. 不用额外空间O(n) 原地置换

哈希表真不戳，但浪费了很多存储空间，能不能在保持时间复杂度O(n)的情况下将空间复杂度降低？

可以将原数组就当做哈希表用。

n长的数组取值范围是0-n-1，也就是说如果没有重复数字，排序后，a[I]恰好等于i。那么在我们将数字归位的过程中，如果发现两个相同数字争夺一个位置时，就代表它重复了。



#####  代码

- 从头开始扫描，索引为 `i=[0~n-1]`，扫描到的值为 `a[i]`为x
  - 比较x与i
    - 如果 `x==i`，则 `i++`，继续比较新的x与i
    - 如果`x!=i`，则比较x与a[x]
      - 如果x==a【x】，则这两个数重复了
      - 如果！=，则交换x与ax，重复比较新的x与i

```c++
//代码非常规整，没有需要注意的下标偏移
int findRepeatNumber(vector<int>& nums) {
    for(int i=0;i<n;i++){
        while(nums[i]!=i){//直到等于，即直到数回归本位，一种类似递归的方法
            if(nums[i]==nums[nums[i]]){//本位已经有数等于本位数，则数重复
                return nums[i];
            }
            swap(nums[i],nums[nums[i]]);
        }
    }
    return -1;//返回-1比返回false等更快，再说要是重复的是0怎么办
}
```



##### 题目2

> 长度为 `n+1` ，取值范围 `[1,n]共n个` 的随机数数组，至少有一个重复值，找出重复数字，不修改原数组。
>
> （上一个题是n长度取0~n-1，这个是n+1长度取1~n）长度增加，区间右移一位

##### 思路

`空间复杂度O(n)` 使用额外空间，用哈希表法。

`空间复杂度O(1)` 不适用额外空间又，不允许修改原数组，所以不能用置换法和排序法；需要设计新方法。



`O(1)` 的空间复杂度要求我们不能建立变长数组，所以只能用单个变量来表示次数等含义；一个变量不能分别给[1,n]里的每个数保存出现次数，但是可以保存一个区间内数值出现的次数；所以我们可以对取值范围进行二分查找，即统计`[1,m]`与`[m+1,n]`这两个区间的值在原数组中出现的次数，若某区间内值出现总次数大于区间长度，则区间中必然有值重复出现在原数组；继续二分此区间，直到含有重复数值的区间长度为1。



当然这种方法有可能漏掉某些重复数字，比如[2,2,3,4,5,6,7,7] 8长数组取1-7，[1,4]区间值出现4次，但2却重复出现了两次，因为一个2代替了1的位置，这种现象暂且叫做`借位`。

虽然可能漏掉某些重复数值，但一定能找出一个重复值，因为n+1长取值[1,n]的数组中，必定有个数为了填补n+1的空缺而无法`借位`地重复出现。



##### 代码

```cpp
int findRepeatNumber(vector<int>& nums) {
    int l=1;//统计区间左边界，左闭
    int r=nums.size()-1;//统计区间右边界，右闭
    while(l<=r){//若连[l,r]长度为1时都没有重复的，则报错
		int mid=((r-l)>>1) + l;//mid将整个区间[l,r)分为两半
        int count=countRange(l,r,nums);//统计区间内数值在原数组中的出现次数
        if(count>mid-r)
            ...
    }
    return -1;
}
int countRange(int l,int r,vector<int>& nums)
```



#### 面试题 04	二维数组中的查找

#### 面试题 05	替换空格

#### 面试题 06	从尾到头打印链表

#### 面试题 07	重建二叉树

#### 面试题 09	用两个栈实现队列

#### 面试题 10- I	斐波那契数列

#### 面试题 10- II	青蛙跳台阶问题  

#### 面试题 11	旋转数组的最小数字

#### 面试题 12	矩阵中的路径

#### 面试题 13	机器人的运动范围  

#### 面试题 14- I	剪绳子  

#### 面试题 14- II	剪绳子 II

#### 面试题 15	二进制中1的个数





## 第3章 高质量的代码 104



#### 面试题 16	数值的整数次方

#### 面试题 17	打印从1到最大的n位数  
#### 面试题 18	删除链表的节点  
#### 面试题 19	正则表达式匹配  
#### 面试题 20	表示数值的字符串  
#### 面试题 21	调整数组顺序使奇数位于偶数前面  
#### 面试题 22	链表中倒数第k个节点  
#### 面试题 24	反转链表  
#### 面试题 25	合并两个排序的链表  
#### 面试题 26	树的子结构



## 第4章 解决面试题的思路 153



#### 面试题 27	二叉树的镜像

#### 面试题 28	对称的二叉树

#### 面试题 29	顺时针打印矩阵  
#### 面试题 30	包含min函数的栈

#### 面试题 31	栈的压入、弹出序列  
#### 面试题 32 - I	从上到下打印二叉树

#### 面试题 32 - II	从上到下打印二叉树 II  
#### 面试题 32 - III	从上到下打印二叉树 III  
#### 面试题 33	二叉搜索树的后序遍历序列  
#### 面试题 34	二叉树中和为某一值的路径  
#### 面试题 35	复杂链表的复制  
#### 面试题 36	二叉搜索树与双向链表  
#### 面试题 37	序列化二叉树  
#### 面试题 38	字符串的排列



## 第5章 优化时间和空间效率 201



#### 面试题 39	数组中出现次数超过一半的数字  
#### 面试题 40	最小的k个数  
#### 面试题 41	数据流中的中位数  
#### 面试题 42	连续子数组的最大和  
#### 面试题 43	1～n 整数中 1 出现的次数  
#### 面试题 44	数字序列中某一位的数字  
#### 面试题 45	把数组排成最小的数  
#### 面试题 46	把数字翻译成字符串  
#### 面试题 47	礼物的最大价值  
#### 面试题 48	最长不含重复字符的子字符串  
#### 面试题 49	丑数  
#### 面试题 50	第一个只出现一次的字符  
#### 面试题 51	数组中的逆序对  
#### 面试题 52	两个链表的第一个公共节点

## 第6章 面试中的各项能力 256



#### 面试题 53 - I	在排序数组中查找数字 I  
#### 面试题 53 - II	0～n-1中缺失的数字  
#### 面试题 54	二叉搜索树的第k大节点  
#### 面试题 55 - I	二叉树的深度  
#### 面试题 55 - II	平衡二叉树  
#### 面试题 56 - I	数组中数字出现的次数  
#### 面试题 56 - II	数组中数字出现的次数 II  
#### 面试题 57	和为s的两个数字  
#### 面试题 57 - II	和为s的连续正数序列  
#### 面试题 58 - I	翻转单词顺序  
#### 面试题 58 - II	左旋转字符串  
#### 面试题 59 - I	滑动窗口的最大值  
#### 面试题 59 - II	队列的最大值  
#### 面试题 60	n个骰子的点数  
#### 面试题 61	扑克牌中的顺子  
#### 面试题 62	圆圈中最后剩下的数字  
#### 面试题 63	股票的最大利润  
#### 面试题 64	求1+2+…+n  
#### 面试题 65	不用加减乘除做加法  
#### 面试题 66	构建乘积数组  
#### 面试题 67	把字符串转换成整数



## 第7章 两个面试案例 315

#### 面试题 68 - I	二叉搜索树的最近公共祖先

#### 面试题 68 - II	二叉树的最近公共祖先  



## 面试题分类目录

### 数据结构类题目

#### LinkedList

面试题06-从尾到头打印链表

面试题22-链表中倒数第k个结点

面试题24-反转链表

面试题25-合并两个排序的链表

面试题35-复杂链表的复制

面试题52-两个链表的第一个公共节点

面试题18-删除链表的节点



#### Tree

面试题07-重建二叉树

面试题26-树的子结构

面试题27-二叉树的镜像

面试题32-1 -从上往下打印二叉树

面试题32-2 -从上往下打印二叉树 2

面试题32-3 -从上往下打印二叉树 3

面试题33-二叉搜索树的后序遍历序列

面试题34-二叉树中和为某一值的路径

面试题36-二叉搜索树与双向链表

面试题55-1-二叉树的深度

面试题55-2-平衡二叉树

面试题28-对称的二叉树

面试题37-序列化二叉树

面试题54-[二叉搜索树的第k大节点](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof)



按算法分类

#### Stack & Queue

面试题09-用两个栈实现队列

面试题30-[包含min函数的栈](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof)

面试题31-栈的压入、弹出序列

面试题58-1-翻转单词顺序

面试题59-1-滑动窗口的最大值



#### Heap

面试题40-最小的K个数



#### Hash Table

面试题50-第一个只出现一次的字符



#### 图

面试题12-矩阵中的路径(BFS)

面试题13-机器人的运动范围(DFS)

### 具体算法类题目

#### 斐波那契数列

面试题10-1-斐波拉契数列

面试题10-2-青蛙跳台阶问题



#### 搜索算法

面试题04-二维数组中的查找

面试题11-旋转数组的最小数字（二分查找）

面试题56-1-数组中数字出现的次数（二分查找）



#### 全排列

面试题38-字符串的排列



#### 动态规划

面试题42-连续子数组的最大和

面试题19-正则表达式匹配(我用的暴力)



#### 回溯

面试题12-矩阵中的路径(BFS)

面试题13-机器人的运动范围(DFS)



#### 排序

面试题51-数组中的逆序对(归并排序)

面试题40-最小的K个数(堆排序)



#### 位运算

面试题15-二进制中1的个数

面试题16-数值的整数次方



#### 其他算法

面试题05-替换空格

面试题21-调整数组顺序使奇数位于偶数前面

面试题39-数组中出现次数超过一半的数字

面试题43- 1～n整数中1出现的次数

面试题45-把数组排成最小的数

面试题49-丑数

面试题57-2-和为S的连续正数序列(滑动窗口思想)

面试题57-和为S的两个数字(双指针思想)

面试题58-2-左旋转字符串(矩阵翻转)

面试题62-圆圈中最后剩下的数(约瑟夫环)

面试题66-构建乘积数组